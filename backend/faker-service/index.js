import express from "express";
import mongoose from "mongoose";
import fs from "fs";
import path from "path";
import axios from "axios";
import dotenv from "dotenv";
import cors from "cors";
import { v4 as uuidv4 } from "uuid";

dotenv.config();

const PORT = process.env.PORT || 4002;
const MONGODB_URI =
  process.env.MONGODB_URI || "mongodb://localhost:27017/musicapp";
const MUSIC_DIR = process.env.MUSIC_DIR || "/music";
const AUTH_REGISTER_URL =
  process.env.AUTH_REGISTER_URL || "http://localhost:8080/api/auth/register";
const DEFAULT_SONG_IMAGE_URL =
  process.env.DEFAULT_SONG_IMAGE_URL ||
  "http://localhost:3000/static/default-song.png";
const DEFAULT_ALBUM_IMAGE_URL =
  process.env.DEFAULT_ALBUM_IMAGE_URL ||
  "http://localhost:3000/static/default-album.png";
const FAKER_BASE_URL =
  process.env.FAKER_BASE_URL || `http://localhost:${PORT}`;
const RECOMMENDATION_SERVICE_URL =
  process.env.RECOMMENDATION_SERVICE_URL || "http://localhost:4003";

const app = express();
app.use(cors());
app.use(express.json());
app.use("/media", express.static(MUSIC_DIR));

// Schemas mirroring music-service
const songSchema = new mongoose.Schema({
  name: String,
  desc: String,
  album: String,
  image: String,
  file: String,
  duration: String,
});
const albumSchema = new mongoose.Schema({
  name: String,
  desc: String,
  bgColour: { type: String, default: "#222" },
  image: String,
});
const playlistSchema = new mongoose.Schema({
  name: String,
  description: String,
  isPublic: { type: Boolean, default: false },
  ownerId: String,
  songs: [{ type: mongoose.Schema.Types.ObjectId, ref: "song" }],
  shareCode: String,
});
const favoriteSchema = new mongoose.Schema(
  {
    userId: String,
    song: { type: mongoose.Schema.Types.ObjectId, ref: "song" },
  },
  { timestamps: true }
);
favoriteSchema.index({ userId: 1, song: 1 }, { unique: true });

const Song = mongoose.model("song", songSchema);
const Album = mongoose.model("album", albumSchema);
const Playlist = mongoose.model("playlist", playlistSchema);
const Favorite = mongoose.model("favorite", favoriteSchema);

const audioExtensions = new Set([".mp3", ".wav", ".ogg", ".m4a", ".flac"]);

async function connectDB() {
  await mongoose.connect(MONGODB_URI);
  console.log("Faker connected to MongoDB");
}

async function createUsers(count = 12) {
  const targetCount = Math.max(6, count);
  const created = [];
  for (let i = 0; i < targetCount; i++) {
    const email = `faker_user_${i + 1}@example.com`;
    try {
      const res = await axios.post(AUTH_REGISTER_URL, {
        email,
        username: `faker${i + 1}`,
        password: "Password123!",
      });
      created.push(res.data?.userId || res.data?.id || email);
    } catch (err) {
      // If user exists, continue
      console.warn("User create skipped", email, err.response?.data || err.message);
      created.push(email);
    }
  }
  return created;
}

function collectAudioFiles(dir) {
  const files = [];
  if (!fs.existsSync(dir)) return files;
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...collectAudioFiles(fullPath));
    } else if (audioExtensions.has(path.extname(entry.name).toLowerCase())) {
      files.push(fullPath);
    }
  }
  return files;
}

function pickRandomSubset(items, size) {
  const arr = [...items];
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr.slice(0, Math.min(size, arr.length));
}

function scheduleFeatureExtraction(song) {
  if (!song?._id || !song?.file) return;

  axios
    .post(`${RECOMMENDATION_SERVICE_URL}/api/recommendation/extract`, {
      songId: song._id,
      file: song.file,
      name: song.name,
      album: song.album,
    })
    .catch((err) =>
      console.warn("Feature extraction queue failed", err.message)
    );
}

async function seedFromMusicDir(userIds) {
  const audioFiles = collectAudioFiles(MUSIC_DIR);

  const albumNames = ["Faker Mix", "Auto Album", "Local Gems"];
  const albums = [];
  for (const name of albumNames) {
    const album = await Album.findOneAndUpdate(
      { name },
      {
        name,
        desc: "Generated by faker service",
        bgColour: "#222",
        image: DEFAULT_ALBUM_IMAGE_URL,
      },
      { upsert: true, new: true }
    );
    albums.push(album);
  }

  const songsCreated = [];
  for (const file of audioFiles) {
    const baseName = path.parse(file).name;
    const album = albums[Math.floor(Math.random() * albums.length)];
    const duration = "3:00";
    const doc = await Song.findOneAndUpdate(
      { name: baseName },
      {
        name: baseName,
        desc: `Local track ${baseName}`,
        album: album.name,
        image: DEFAULT_SONG_IMAGE_URL,
        file: `${FAKER_BASE_URL}/media/${encodeURIComponent(path.relative(MUSIC_DIR, file))}`,
        duration,
      },
      { upsert: true, new: true }
    );
    songsCreated.push(doc);
    scheduleFeatureExtraction(doc);
  }

  // Add synthetic tracks if not enough to satisfy favorites/playlists targets
  const minimumSongs = 30;
  if (songsCreated.length < minimumSongs) {
    const needed = minimumSongs - songsCreated.length;
    for (let i = 0; i < needed; i++) {
      const idx = songsCreated.length + i + 1;
      const doc = await Song.findOneAndUpdate(
        { name: `Generated Track ${idx}` },
        {
          name: `Generated Track ${idx}`,
          desc: "Auto-generated track for seeding",
          album: "Auto Album",
          image: DEFAULT_SONG_IMAGE_URL,
          file: "",
          duration: "3:00",
        },
        { upsert: true, new: true }
      );
      songsCreated.push(doc);
    }
  }

  const playlist = await Playlist.findOneAndUpdate(
    { name: "Faker Playlist" },
    {
      name: "Faker Playlist",
      description: "Auto-generated playlist",
      isPublic: true,
      ownerId: userIds[0] || "faker",
      songs: songsCreated.map((s) => s._id),
      shareCode: uuidv4().slice(0, 8),
    },
    { upsert: true, new: true }
  );

  // Favorites: ensure each user has at least 20 unique favorites
  for (const userId of userIds.slice(0, Math.max(6, userIds.length))) {
    const selection = pickRandomSubset(songsCreated, 20);
    for (const song of selection) {
      await Favorite.findOneAndUpdate(
        { userId, song: song._id },
        { userId, song: song._id },
        { upsert: true }
      );
    }
  }

  // Playlists: 12-18 per user, 5-18 songs each, all public
  for (const userId of userIds.slice(0, Math.max(6, userIds.length))) {
    const playlistCount = 12 + Math.floor(Math.random() * 7); // 12-18
    for (let i = 0; i < playlistCount; i++) {
      const songCount = 5 + Math.floor(Math.random() * 14); // 5-18
      const songs = pickRandomSubset(songsCreated, songCount);
      await Playlist.create({
        name: `Playlist ${i + 1} - ${userId}`,
        description: "Auto-generated playlist",
        isPublic: true,
        ownerId: userId,
        songs: songs.map((s) => s._id),
        shareCode: uuidv4().slice(0, 8),
      });
    }
  }

  return { songsCreated: songsCreated.length, playlistId: playlist?._id };
}

app.get("/health", (req, res) => res.json({ ok: true }));

app.post("/api/faker/seed", async (req, res) => {
  try {
    const userCount = Number(req.body?.userCount) || 12;
    const users = await createUsers(userCount);
    const seedResult = await seedFromMusicDir(users);
    return res.json({
      success: true,
      usersCreated: users.length,
      ...seedResult,
    });
  } catch (err) {
    console.error("Seeder failed", err);
    return res.status(500).json({ success: false, message: err.message });
  }
});

connectDB().then(() => {
  app.listen(PORT, () =>
    console.log(`Faker service running on ${PORT}, media at /media`)
  );
});
